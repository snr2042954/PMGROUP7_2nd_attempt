\section{Implementation}\label{sec:implementation}

This section describes our implementation to ensure reproducibility. The codebase is a modular Python~3.8+ project organized into core discovery, evaluation, and visualization components. The module \texttt{alpha\_miner.py} contains our frequency-enhanced $\alpha$-miner implementation; \texttt{utils/import\_xes.py} handles XES parsing and lifecycle filtering; \texttt{evaluate.py} provides evaluation functions comparing discovered models against gold standards; \texttt{grid\_search.py} orchestrates parameter grid searches; and \texttt{main.py} runs the complete experimental pipeline.\newline

We use a minimal dependency stack (Table~\ref{tab:dependencies}). \texttt{lxml} parses XES files and extracts \texttt{concept:name} and \texttt{lifecycle:transition} attributes. \texttt{pm4py} is used exclusively for baseline comparisons (Alpha and Heuristics miners) and optional visualization; it is never part of our discovery logic. \texttt{graphviz} renders Petri nets to PNG/SVG for visualization. \texttt{matplotlib} and \texttt{networkx} are required by PM4Py for visualization.\newline

All logs undergo identical normalization before discovery: if the \texttt{lifecycle:transition} attribute exists, only events with state \emph{complete} are retained; logs without lifecycle information are processed unchanged. This filtering is applied identically to our runs and PM4Py baselines to ensure observed differences are algorithmic rather than due to preprocessing.\newline

Experiments are fully scripted and deterministic. Requirement~(i) runs our miner with default parameters (absolute frequency $f{=}0$, relative frequency $r{=}0.0$) and PM4Py Alpha on the same filtered logs. Requirement~(ii) executes a fixed parameter grid ($f\in\{1,2,\dots,10\}$ and $r\in\{0.0, 0.05, 0.1, \dots, 0.5\}$) per dataset, totaling 110 parameter combinations. Requirement~(iii) re-runs our miner with the best $(f,r)$ per dataset and compares against PM4Py Heuristics Miner. There is no randomness in discovery or evaluation, so results are exactly reproducible.\newline

Running the full pipeline requires only installing dependencies and executing \texttt{main.py}. After \texttt{pip install -r requirements.txt}, all three requirements are executed automatically by running \texttt{python main.py} (or \texttt{python main.py --save} to redirect output to \texttt{results.txt}). The script performs grid search, evaluates all miners, and generates visualizations. Results are printed to console (or saved to \texttt{results.txt}) with precision, recall, F1-scores, and confusion matrix metrics (TP, FP, FN, TN). An HTML comparison report can be generated from \texttt{results.txt} using \texttt{python generate\_report.py}, which produces \texttt{results/comparison\_report.html}. Gold standards can be visualized with \texttt{python visualize\_gold\_standards.py}, saving PNG files to \texttt{results/gold\_standard\_visualizations/}.\newline

\begin{table}[h]
\centering
\caption{Core software dependencies}
\label{tab:dependencies}
\begin{tabular}{|l|l|}
\hline
\textbf{Package} & \textbf{Purpose} \\ \hline
lxml ($\geq$ 6.0) & XES file parsing and XML processing \\ \hline
pm4py ($\geq$ 2.7.0) & Baseline comparisons (Alpha and Heuristics miners) \\ \hline
graphviz ($\geq$ 0.20) & Petri net visualization \\ \hline
matplotlib, networkx & Required by PM4Py for visualization \\ \hline
\end{tabular}
\end{table}

Scope and separation of concerns are intentional: PM4Py is used purely for baselines and rendering; our discovery follows the formal $\alpha$-miner definitions and runs on normalized (complete-only) logs. Frequency-based filtering is layered on top to enable thresholded evaluations, but the underlying construction remains identical to the textbook $\alpha$-miner. This design keeps the formal core intact while making experiments repeatable and outputs auditable.

